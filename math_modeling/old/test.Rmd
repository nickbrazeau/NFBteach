---
title: "Simulating & Solving ID Epidemiological Parameters"
date: "`r format(Sys.time(), '%B %d, %Y')`"
editor_options: 
  chunk_output_type: console
runtime: shiny
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F, fig.align = 'center', results = 'hide', fig.keep = 'all')
library(tidyverse)
library(patchwork)
library(odin)
```

## Overview
The basic skeleton of all parameter estimation within these Ecological/SIR-ish/math models is that we have some set of parameters $\mathbb{\theta}$ that are unknown. But, we assume that we know the underlying model that is generating these observations over time (_i.e._ this is a time series problem). Given that this a time-series problem and our observations are generated by some underlying process, this problem can be characterized with the **hidden Markov model** framework. 

#### Digression
If the models are simple enough, they have analytical solutions that can be determined by solving the ordinary differential equations (ODEs). We typically call these deterministic models. You can solve these models with a "simulation" or "optimization" based approach, but it's not necessary. Most models aren't simple...

### Approach 
The basic steps for solving these models then is to simulate data under our set of parameters $\mathbb{\theta}$ and see how closely it matches truth.


```{r}
# stochastic simulator for the unobserved state process --> how cases are generated
seir_step <- function(S, E, I, R, N, Beta, mu_EI, mu_IR, delta.t){
  dN_SE <- rbinom(n = 1, size = S, prob = 1 - exp(-Beta*(I/N)*delta.t))
  dN_EI <- rbinom(n = 1, size = E, prob = 1 - exp(-mu_EI*delta.t))
  dN_IR <- rbinom(n = 1, size = I, prob = 1 - exp(-mu_IR*delta.t))
  S <- S - dN_SE
  E <- E + dN_SE - dN_EI
  I <- I + dN_EI - dN_IR
  R <- R + dN_IR
  return(c("S" = S, "E" = E, "I" = I, "R" = R))
}

# recursively just step through time now
seir_wrapper <-  function(N, E0, I0, R0, Beta, mu_EI, mu_IR, time, ...){
  # set up
 S0 <- N - I0 - E0 - R0
 time.steps <- (time - dplyr::lag(time))
 # init 
 ret <- matrix(NA, nrow = length(time.steps) , ncol = 4)
 ret[1,] <- seir_step(S = S0, E = E0, 
                      I = I0, R = R0, N = N, 
                      Beta = Beta, 
                      mu_EI = mu_EI, 
                      mu_IR = mu_IR, delta.t = 0)
 
 for (t in 2:length(time.steps)) {
   ret[t,] <-  seir_step(S = ret[t-1, 1], 
                         E = ret[t-1, 2], 
                         I = ret[t-1, 3], 
                         R = ret[t-1, 4], 
                         N = N, # closed population
                         Beta = Beta, 
                         mu_EI = mu_EI, 
                         mu_IR = mu_IR, 
                         delta.t = time.steps[t]
                         )
 }
 # out
 ret <- cbind.data.frame(time, ret)
 colnames(ret) <- c("time", "S", "E", "I", "R")
 return(ret)
 
}

seir.odin <- odin::odin({
  
  # derivatives 
  deriv(S) <- -beta * S * I / N 
  deriv(E) <- beta * S * I / N - mu_EI * E
  deriv(I) <- mu_EI * E - mu_IR * I
  deriv(R) <- mu_IR * I
  
  # initial conditions
  initial(S) <- N - I0
  initial(E) <- E0
  initial(I) <- I0
  initial(R) <- R0
  
  I0 <- user(1) # note user allows you to vary if you want
  N <- user(1e7)
  E0 <- user(0)
  R0 <- user(0)
  
  beta <- user(10)
  mu_EI <- user(0.01)
  mu_IR <- user(0.05)
  
})

```

```{r, results='asis'}
#..............................................................
# Sliding Panel for Different Parameters we are estimating
#..............................................................


selectInput("runmcmc", label = "Run (MC)MCMC?",
              choices = c(No="no",
                          Yes = "yes"))

conditionalPanel(
      condition = "input.runmcmc == 'yes'",
      sliderInput("N", label = "Number of People in Population",
              min = 1e4, max = 1e6, value = 1e5, step = 5e4),
      
      sliderInput("Time", label = "Time Observed Since Start of Epidemic",
              min = 1, max = 500, value = 100, step = 50),
      
      sliderInput("beta", label = "Beta (Effective Contact Rate)",
              min = 0, max = 50, value = 15, step = 0.5),
      
      sliderInput("mu_EI", label = "EI (Rrate of Infectiousness)",
              min = 0, max = 10, value = 0.05, step = 0.1),
      
      sliderInput("mu_IR", label = "IR (Rate of Recovery)",
              min = 0, max = 10, value = 0.02, step = 0.1),
      
      sliderInput("burnin", label = "Burn-In Iterations for MCMC",
              min = 100, max = 1e4, value = 1e3, step = 500),
      
      sliderInput("sampling", label = "Sampling Iterations for MCMC",
               min = 100, max = 1e4, value = 1e3, step = 500),
      
      sliderInput("rungs", label = "Rungs for Metropolic Coupling MCMC",
              min = 1, max = 50, value = 10, step = 5)
   )




```

```{r, results='asis', fig.align='center', fig.height=40, fig.width=10}

renderPlot({ withProgress(message = 'Making plot', {
  
  if(input$runmcmc  == "no"){
    grid::rectGrob(gp=grid::gpar(col="white"))
  } else {
    #..............................................................
  # truth
  #..............................................................
  # note, we have to work backwards to get E0
  # because if one person is infected, that means people must be exposed
  # R0 is Ce/D, so we can back calculate here: 
  truth <- seir_wrapper(N = input$N,
                        E0 = round(input$beta / (input$mu_EI + input$mu_IR)),
                        I0 = 1,
                        R0 = 0,
                        Beta = input$beta,
                        mu_EI = input$mu_EI,
                        mu_IR = input$mu_IR,
                        time = 1:input$Time)
  
  #..............................................................
  # set up odin for Dr. Jacoby
  #..............................................................
  mod <- seir.odin(
  beta = input$beta,
  mu_EI = input$mu_EI,
  mu_IR = input$mu_IR,
  N = input$N,
  I0 = 1,
  E0 = 0,
  R0 = 0)


  
  #..............................................................
  # Run MCMC
  #..............................................................
  # We don't see full curve -- only see infxns.
  obs.data <- data.frame(time = truth$time, 
                         infxns = truth$I)
  
    
    # https://mrc-ide.github.io/drjacoby/articles/example.html
    devtools::install_github("mrc-ide/drjacoby", ref = "3e915113ea960e09a4b30eb9e661331ab66da020")
    library(drjacoby)
    #..............................................................
    # Set up Dr. Jacoby
    #..............................................................
    
    # let's assume that the true number of infections in our population can be
    # modeled through the parameter p, which reflects a combination of 
    # sampling efficiency and the detectability of infections
    
    r_loglike <- function(params, param_i, data, misc){
      mod <- seir.odin(
        beta = params[1],
        mu_EI = params[2],
        mu_IR = params[3],
        N = input$N,
        I0 = 1,
        E0 = 0,
        R0 = 0
      )
      modrun <- mod$run(1:input$Time) # assume time is fixed
      I <- modrun[, "I"]
      I[I < 0] <- .Machine$double.xmin # catch
      ret <- dpois(data$obs.data, lambda = I, log = T)
      ret <- sum(ret)
      return(ret)
    }
    
    # define log-prior function
    r_logprior <- function(params, param_i, misc) {
      # extract parameter values
      beta = params[1]
      mu_EI = params[2]
      mu_IR = params[3]
      
      # calculate prior
      ret <- dunif(beta, min = 1, max = 100, log = TRUE) 
      dunif(mu_EI, min = 0, max = 1, log = TRUE) +
        dunif(mu_IR, min = 0, max = 1, log = TRUE) 
      
      # return
      return(ret)
    }
    
    # define parameters dataframe
    df_params <- data.frame(name = c("beta", "mu_EI", "mu_IR"),
                            min = c(0.1, 0.001, 0.001),
                            max = c(50, 1, 1),
                            init = c(10, 0.05, 0.05))
    
    
    data_list <- list(obs.data = obs.data$infxns)
    # run MCMC
    r_mcmc_out <- run_mcmc(data = data_list,
                           df_params = df_params,
                           loglike = r_loglike,
                           logprior = r_logprior,
                           misc = list(foo = 99),
                           burnin = input$burnin,
                           samples = input$sampling,
                           chains = 3,
                           rungs = input$rungs, 
                           GTI_pow = 3.0,
                           pb_markdown = TRUE)
    
    #..............................................................
    # plot MCMC outs
    #..............................................................
    beta.post.plot <- plot_par(r_mcmc_out, show = "beta", phase = "sampling", display = F)
    beta.post.plot$Plot_beta[[2]] <-beta.post.plot$Plot_beta[[2]] + 
      geom_vline(xintercept = input$beta, color = "red", size = 2)
    beta.post.plot <- (beta.post.plot$Plot_beta[[1]]) / (beta.post.plot$Plot_beta[[2]] | beta.post.plot$Plot_beta[[3]])
    
    mu_EI.post.plot <- plot_par(r_mcmc_out, show = "mu_EI", phase = "sampling", display = F)
    mu_EI.post.plot$Plot_mu_EI[[2]] <- mu_EI.post.plot$Plot_mu_EI[[2]] + 
      geom_vline(xintercept = input$mu_EI, color = "red", size = 2)
    mu_EI.post.plot <- (mu_EI.post.plot$Plot_mu_EI[[1]]) / (mu_EI.post.plot$Plot_mu_EI[[2]] | mu_EI.post.plot$Plot_mu_EI[[3]])
    
    mu_IR.post.plot <- plot_par(r_mcmc_out, show = "mu_IR", phase = "sampling", display = F)
    mu_IR.post.plot$Plot_mu_IR[[2]] <- mu_IR.post.plot$Plot_mu_IR[[2]] + 
      geom_vline(xintercept = input$mu_IR, color = "red", size = 2)
    mu_IR.post.plot <- (mu_IR.post.plot$Plot_mu_IR[[1]]) / (mu_IR.post.plot$Plot_mu_IR[[2]] | mu_IR.post.plot$Plot_mu_IR[[3]])
    
    
    #..............................................................
    # Final plots out
    #..............................................................
   beta.post.plot / mu_EI.post.plot / mu_IR.post.plot

  }
  
}) # end of progress bar
  
}, height = 400)



```
