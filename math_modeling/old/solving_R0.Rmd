---
title: "Solving R_0"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F, fig.align = 'center', results = 'hide', fig.keep = 'all')
```
```{r}
library(tidyverse)
library(patchwork)
```

## Overview
The basic skeleton of all parameter estimation within these Ecological/SIR-ish/math models is that we have some set of parameters $\mathbb{\theta}$ that are unknown. But, we assume that we know the underlying model that is generating these observations over time (_i.e._ this is a time series problem). Given that this a time-series problem and our observations are generated by some underlying process, this problem can be characterized with the **hidden Markov model** framework. 

#### Digression
If the models are simple enough, they have analytical solutions that can be determined by solving the ordinary differential equations (ODEs). We typically call these deterministic models. You can solve these models with a "simulation" or "optimization" based approach, but it's not necessary. Most models aren't simple...

### Approach 
The basic steps for solving these models then is to simulate data under our set of parameters $\mathbb{\theta}$ and see how closely it matches truth.


```{r}
# stochastic simulator for the unobserved state process --> how cases are generated
seir_step <- function(S, E, I, R, N, Beta, mu_EI, mu_IR, delta.t){
  dN_SE <- rbinom(n = 1, size = S, prob = 1 - exp(-Beta*(I/N)*delta.t))
  dN_EI <- rbinom(n = 1, size = E, prob = 1 - exp(-mu_EI*delta.t))
  dN_IR <- rbinom(n = 1, size = I, prob = 1 - exp(-mu_IR*delta.t))
  S <- S - dN_SE
  E <- E + dN_SE - dN_EI
  I <- I + dN_EI - dN_IR
  R <- R + dN_IR
  return(c("S" = S, "E" = E, "I" = I, "R" = R))
}

# recursively just step through time now
seir_wrapper <-  function(N, E0, I0, R0, Beta, mu_EI, mu_IR, time, ...){
  # set up
 S0 <- N - I0 - E0 - R0
 time.steps <- (time - dplyr::lag(time))
 # init 
 ret <- matrix(NA, nrow = length(time.steps) , ncol = 4)
 ret[1,] <- seir_step(S = S0, E = E0, 
                      I = I0, R = R0, N = N, 
                      Beta = Beta, 
                      mu_EI = mu_EI, 
                      mu_IR = mu_IR, delta.t = 0)
 
 for (t in 2:length(time.steps)) {
   ret[t,] <-  seir_step(S = ret[t-1, 1], 
                         E = ret[t-1, 2], 
                         I = ret[t-1, 3], 
                         R = ret[t-1, 4], 
                         N = N, # closed population
                         Beta = Beta, 
                         mu_EI = mu_EI, 
                         mu_IR = mu_IR, 
                         delta.t = time.steps[t]
                         )
 }
 # out
 ret <- cbind.data.frame(time, ret)
 colnames(ret) <- c("time", "S", "E", "I", "R")
 return(ret)
 
}

```


```{r}
# https://shiny.dide.imperial.ac.uk/infectiousdiseasemodels-2019/files/introduction/seirs.R
library(odin)
seir.odin <- odin::odin({
  
  # derivatives 
  deriv(S) <- -beta * S * I / N 
  deriv(E) <- beta * S * I / N - mu_EI * E
  deriv(I) <- mu_EI * E - mu_IR * I
  deriv(R) <- mu_IR * I
  
  # initial conditions
  initial(S) <- N - I0
  initial(E) <- E0
  initial(I) <- I0
  initial(R) <- R0
  
  I0 <- user(1) # note user allows you to vary if you want
  N <- user(1e7)
  E0 <- user(0)
  R0 <- user(0)
  
  beta <- user(10)
  mu_EI <- user(0.01)
  mu_IR <- user(0.05)
  
})

```


```{r}
#..............................................................
# truth
#..............................................................
# note, we have to work backwards to get E0
# because if one person is infected, that means people must be exposed
# R0 is Ce/D, so we can back calculate here: 
N <- 1e5
true_beta <- 15
true_mu_IR <- 0.02
true_mu_EI <- 0.05
E0 <- round(true_beta / (true_mu_EI + true_mu_IR))
I0 <- 1
R0 <- 0


truth <- seir_wrapper(N = N,
                      E0 = E0,
                      I0 = I0,
                      R0 = R0,
                      Beta = true_beta,
                      mu_EI = true_mu_EI,
                      mu_IR = true_mu_IR,
                      time = 1:50)



mod <- seir.odin(
  beta = 15,
  mu_EI = 0.05,
  mu_IR = 0.02,
  N = 1e5,
  I0 = 1,
  E0 = 0,
  R0 = 0)


```

```{r, results='asis'}

truth %>% 
  tidyr::gather(., key = "compartment", "count", 2:ncol(.)) %>% 
  dplyr::mutate(compartment = factor(compartment, levels = c("S", "E", "I", "R"))) %>% 
  ggplot() + 
  geom_line(aes(x=time, y=count, color = factor(compartment)), size = 2) +
  scale_color_manual("Compartment", values = c( "#4daf4a", "#377eb8", "#e41a1c", "#984ea3")) +
  xlab("Time") + ylab("N") +
  theme_bw() +
  theme(
    axis.title = element_text(family = "Helvetica", face = "bold", vjust = 0.5, size = 15),
    axis.text = element_text(family = "Helvetica", hjust = 0.5, vjust = 0.5, size = 14),
    legend.title = element_text(family = "Helvetica", face = "bold", vjust = 0.5, size = 15),
    legend.text = element_text(family = "Helvetica", hjust = 0.5, vjust = 0.5, size = 14),
    panel.background = element_rect(fill = "transparent"),
    plot.background = element_rect(fill = "transparent"))
  
```

We don't see full curve -- only see infxns.
```{r}
obs.data <- data.frame(time = truth$time, 
                       infxns = truth$I)

```


### Using `drjacoby` for MCMC inference of parameters
I now have a model that can generate data under a give set of parameters. Here, we are going to assume that we know the number of susceptible individuals and that this is a new, immunizing infeection. We will assume that we can only detect infectoins and that rates are poisson distributed. We want to estimate the $\beta$ parameter -- which is the constant part of the force of infection (really estimating $\frac{\beta}{N}$ because in a frequency-dependent state) -- as well as the $\mu_{EI}$ and $\mu_{IR}$ parameters, which represent decay into the infected from exposed and infected to recovered compartments. 

```{r}
# https://mrc-ide.github.io/drjacoby/articles/example.html
devtools::install_github("mrc-ide/drjacoby", ref = "3e915113ea960e09a4b30eb9e661331ab66da020")
library(drjacoby)
#..............................................................
# Set up Dr. Jacoby
#..............................................................

# let's assume that the true number of infections in our population can be
# modeled through the parameter p, which reflects a combination of 
# sampling efficiency and the detectability of infections

r_loglike <- function(params, param_i, data, misc){
  mod <- seir.odin(
            beta = params[1],
            mu_EI = params[2],
            mu_IR = params[3],
            N = 1e5,
            I0 = 1,
            E0 = 0,
            R0 = 0
            )
  modrun <- mod$run(1:50) # assume time is fixed
  I <- modrun[, "I"]
  I[I < 0] <- .Machine$double.xmin # catch
  ret <- dpois(data$obs.data, lambda = I, log = T)
  ret <- sum(ret)
  return(ret)
}

# define log-prior function
r_logprior <- function(params, param_i, misc) {
  # extract parameter values
  beta = params[1]
  mu_EI = params[2]
  mu_IR = params[3]
  
  # calculate prior
  ret <- dunif(beta, min = 1, max = 50, log = TRUE) 
         dunif(mu_EI, min = 0, max = 1, log = TRUE) +
         dunif(mu_IR, min = 0, max = 1, log = TRUE) 
  
  # return
  return(ret)
}

# define parameters dataframe
df_params <- data.frame(name = c("beta", "mu_EI", "mu_IR"),
                        min = c(0.1, 0.001, 0.001),
                        max = c(50, 1, 1),
                        init = c(10, 0.05, 0.05))


data_list <- list(obs.data = obs.data$infxns)
# run MCMC
r_mcmc_out <- run_mcmc(data = data_list,
                       df_params = df_params,
                       loglike = r_loglike,
                       logprior = r_logprior,
                       misc = list(foo = 99),
                       burnin = 1e3,
                       samples = 1e3,
                       chains = 3,
                       rungs = 1, 
                       GTI_pow = 3.0,
                       pb_markdown = TRUE)



#..............................................................
# plot outs
#..............................................................
beta.post.plot <- plot_par(r_mcmc_out, show = "beta", phase = "sampling", display = F)
beta.post.plot$Plot_beta[[2]] <-beta.post.plot$Plot_beta[[2]] + 
  geom_vline(xintercept = true_beta, color = "red", size = 2)
beta.post.plot <- (beta.post.plot$Plot_beta[[1]]) / (beta.post.plot$Plot_beta[[2]] | beta.post.plot$Plot_beta[[3]])

mu_EI.post.plot <- plot_par(r_mcmc_out, show = "mu_EI", phase = "sampling", display = F)
mu_EI.post.plot$Plot_mu_EI[[2]] <- mu_EI.post.plot$Plot_mu_EI[[2]] + 
  geom_vline(xintercept = true_mu_EI, color = "red", size = 2)
mu_EI.post.plot <- (mu_EI.post.plot$Plot_mu_EI[[1]]) / (mu_EI.post.plot$Plot_mu_EI[[2]] | mu_EI.post.plot$Plot_mu_EI[[3]])

mu_IR.post.plot <- plot_par(r_mcmc_out, show = "mu_IR", phase = "sampling", display = F)
mu_IR.post.plot$Plot_mu_IR[[2]] <- mu_IR.post.plot$Plot_mu_IR[[2]] + 
  geom_vline(xintercept = true_mu_IR, color = "red", size = 2)
mu_IR.post.plot <- (mu_IR.post.plot$Plot_mu_IR[[1]]) / (mu_IR.post.plot$Plot_mu_IR[[2]] | mu_IR.post.plot$Plot_mu_IR[[3]])

```


```{r, results='asis', fig.width=8, fig.height= 30}
beta.post.plot / mu_EI.post.plot / mu_IR.post.plot 
```


